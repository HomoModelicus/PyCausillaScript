
from __future__ import annotations

from opcodes import *
from objects import *





"""
function fib(n: Int) -> Int
    if (n <= 1)
        return 1;
    else
        var f1: Int = fib(n - 1)
        var f2: Int = fib(n - 2)
        return f1 + f2;
    end
end
"""
def create_fib() -> Value:
    global type_table
    int_type_ptr  = type_table.get_int_ptr()
    arg_type_list = [int_type_ptr]
    fcn_type      = FunctionType(arg_type_list, int_type_ptr)
    n_args        = 1
    fcn           = CompiledFunction("fibonacci", n_args, fcn_type)
    val           = make_function_value(fcn)

    fcn.append_constant( make_int_value(1) ) # in if cond
    fcn.append_constant( make_int_value(1) ) # in return
    fcn.append_constant( make_int_value(1) ) # in fib(n - 1)
    fcn.append_constant( make_int_value(2) ) # in fib(n - 2)
    fcn.append_constant( val ) # fib
    

    fcn.append_opcode(OpCode.GET_LOCAL)
    fcn.append_opcode(1) # n
    fcn.append_opcode(OpCode.GET_CONSTANT)
    fcn.append_opcode(0) # 1
    fcn.append_opcode(OpCode.LESSTHEN_I64)

    fcn.append_opcode(OpCode.JUMP_FW_IF_FALSE)
    fcn.append_opcode( 0 + 3 ) # to be set

    # true branch
    fcn.append_opcode(OpCode.GET_CONSTANT)
    fcn.append_opcode(1) # 1
    fcn.append_opcode(OpCode.RETURN)

    # false branch
    fcn.append_opcode(OpCode.GET_CONSTANT)
    fcn.append_opcode(4) # fib
    fcn.append_opcode(OpCode.GET_LOCAL)
    fcn.append_opcode(1) # n
    fcn.append_opcode(OpCode.GET_CONSTANT)
    fcn.append_opcode(2) # 1
    fcn.append_opcode(OpCode.MINUS_I64)
    fcn.append_opcode(OpCode.CALL)
    fcn.append_opcode(1) # with 1 argument

    fcn.append_opcode(OpCode.GET_CONSTANT)
    fcn.append_opcode(4) # fib
    fcn.append_opcode(OpCode.GET_LOCAL)
    fcn.append_opcode(1) # n
    fcn.append_opcode(OpCode.GET_CONSTANT)
    fcn.append_opcode(3) # 2
    fcn.append_opcode(OpCode.MINUS_I64)
    fcn.append_opcode(OpCode.CALL)
    fcn.append_opcode(1) # with 1 argument

    fcn.append_opcode(OpCode.PLUS_I64)
    fcn.append_opcode(OpCode.RETURN)

    return val



# TODO: this is only a temporary solution, trying out the vm
def create_main_function_value() -> Value:
    fib_fcn_value = create_fib()

    global type_table
    nil_type_ptr  = type_table.get_nil_ptr()
    main_fcn_type = FunctionType([], nil_type_ptr)
    fcn           = CompiledFunction("main", 0, main_fcn_type)
    val           = make_function_value(fcn)


    # n_th_fib = 1  # 1
    # n_th_fib = 2  # 2
    # n_th_fib = 3  # 3
    # n_th_fib = 4  # 5
    # n_th_fib = 5  # 8
    # n_th_fib = 6  # 13
    # n_th_fib = 7  # 21
    # n_th_fib = 8  # 34
    # n_th_fib = 9  # 55
    # n_th_fib = 10 # 89

    n_th_fib = 11 # 144
    # n_th_fib = 12 # 233
    # n_th_fib = 13 # 377
    # n_th_fib = 14 # 610
    # n_th_fib = 15 # 987
    # n_th_fib = 16 # 1597
    # n_th_fib = 17 # 2584
    # n_th_fib = 18 # 4181
    # n_th_fib = 25 # 25	121393
    

    fcn.append_constant( fib_fcn_value )
    fcn.append_constant( make_int_value(n_th_fib) )
    fcn.append_constant( make_string_value("n: ") )
    fcn.append_constant( make_string_value("fib(n): ") )
    
    fcn.append_opcode(OpCode.GET_CONSTANT)
    fcn.append_opcode(0) # fib

    fcn.append_opcode(OpCode.GET_CONSTANT)
    fcn.append_opcode(1) # n


    fcn.append_opcode(OpCode.GET_CONSTANT)
    fcn.append_opcode(2) # string
    fcn.append_opcode(OpCode.PRINT)

    fcn.append_opcode(OpCode.GET_CONSTANT)
    fcn.append_opcode(1) # n
    fcn.append_opcode(OpCode.PRINT)

    
    fcn.append_opcode(OpCode.CALL)
    fcn.append_opcode(1) # with 1 argument

    fcn.append_opcode(OpCode.GET_CONSTANT)
    fcn.append_opcode(3) # string
    fcn.append_opcode(OpCode.PRINT)

    fcn.append_opcode(OpCode.PRINT) # this shall print the n-th fib

    fcn.append_opcode(OpCode.PUSH_NIL)
    fcn.append_opcode(OpCode.RETURN)

    return val

    # define 2 variables
    # add them together
    # print the result
    # return nil

    # lhs = make_real_value(25.3)
    # rhs = make_real_value(22.3)
    # fcn.append_constant(lhs)
    # fcn.append_constant(rhs)
    # 
    # fcn.append_opcode(OpCode.GET_CONSTANT)
    # fcn.append_opcode(0)
    # fcn.append_opcode(OpCode.GET_CONSTANT)
    # fcn.append_opcode(1)
    # fcn.append_opcode(OpCode.MINUS_F64)
    # fcn.append_opcode(OpCode.GET_LOCAL)
    # fcn.append_opcode(1)
    # fcn.append_opcode(OpCode.PRINT)
    # fcn.append_opcode(OpCode.PUSH_NIL)
    # fcn.append_opcode(OpCode.RETURN)
    # 
    # 
    # val = make_function_value(fcn)
    # return val





def create_starter_callframe() -> CallFrame:
    # TODO: this whole starter callframe shall be generated by the compiler

    main_fcn_value = create_main_function_value()

    global type_table
    nil_type_ptr   = type_table.get_nil_ptr()
    start_fcn_type = FunctionType([], nil_type_ptr)
    fcn = CompiledFunction("__start__", 0, start_fcn_type)

    fcn.append_constant(main_fcn_value)

    fcn.append_opcode(OpCode.GET_CONSTANT) # here is the main function
    fcn.append_opcode(0)
    fcn.append_opcode(OpCode.CALL)
    fcn.append_opcode(0)
    fcn.append_opcode(OpCode.RETURN)

    

    cf = CallFrame(fcn, 0)
    return cf










class CallFrame:
    def __init__(
            self,
            fcn: CompiledFunction,
            return_stack_address: int
        ):
        self.m_fcn = fcn
        self.m_instr_ptr = 0
        self.m_return_stack_address = return_stack_address

    def return_stack_address(self) -> int:
        return self.m_return_stack_address

    def local_index(self, relative_index: int) -> int:
        return self.m_return_stack_address + relative_index

    def instr_ptr(self) -> int:
        return self.m_instr_ptr

    def incr_instr_ptr(self, inc: int = 1) -> None:
        self.m_instr_ptr += inc

    def decr_instr_ptr(self, inc: int = 1) -> None:
        self.m_instr_ptr -= inc
    
    def current_function(self) -> CompiledFunction:
        return self.m_fcn

    def opcode(self) -> OpCode:
        ip = self.instr_ptr()
        op = self.m_fcn.opcode_at(ip)
        self.incr_instr_ptr()
        return op





def float_binary_operator(lhs: Value, rhs: Value, op_code: OpCode) -> Value:
    xl = as_real(lhs)
    xr = as_real(rhs)
    
    match op_code:
            case OpCode.PLUS_F64:
                res = xl + xr
                return make_real_value(res)
            
            case OpCode.MINUS_F64:
                res = xl - xr
                return make_real_value(res)
            
            case OpCode.PROD_F64:
                res = xl * xr
                return make_real_value(res)
            
            case OpCode.DIVIDE_F64:
                res = xl / xr
                return make_real_value(res)
            
            case OpCode.POWER_F64:
                res = xl ** xr
                return make_real_value(res)

            case OpCode.LESS_F64:
                res = xl < xr
                return make_bool_value(res)

            case OpCode.LESSTHEN_F64:
                res = xl <= xr
                return make_bool_value(res)

            case OpCode.GREATER_F64:
                res = xl > xr
                return make_bool_value(res)

            case OpCode.GREATERTHEN_F64:
                res = xl >= xr
                return make_bool_value(res)

            case OpCode.EQUALEQUAL_F64:
                res = xl == xr
                return make_bool_value(res)

            case OpCode.NOTEQUAL_F64:
                res = xl != xr
                return make_bool_value(res)

            case _:
                raise Exception("implementation error")



def int_binary_operator(lhs: Value, rhs: Value, op_code: OpCode) -> Value:
    xl = as_int(lhs)
    xr = as_int(rhs)
    
    match op_code:
        case OpCode.PLUS_I64:
            res = xl + xr
            return make_int_value(res)
        
        case OpCode.MINUS_I64:
            res = xl - xr
            return make_int_value(res)
        
        case OpCode.PROD_I64:
            res = xl * xr
            return make_int_value(res)
        
        case OpCode.DIVIDE_I64:
            res = xl / xr
            return make_int_value(res)
        
        case OpCode.POWER_I64:
            res = xl ** xr
            return make_int_value(res)

        case OpCode.LESS_I64:
            res = xl < xr
            return make_bool_value(res)

        case OpCode.LESSTHEN_I64:
            res = xl <= xr
            return make_bool_value(res)

        case OpCode.GREATER_I64:
            res = xl > xr
            return make_bool_value(res)

        case OpCode.GREATERTHEN_I64:
            res = xl >= xr
            return make_bool_value(res)

        case OpCode.EQUALEQUAL_I64:
            res = xl == xr
            return make_bool_value(res)

        case OpCode.NOTEQUAL_I64:
            res = xl != xr
            return make_bool_value(res)

        case _:
            raise Exception("implementation error")





class VirtualMachine:
    # value stack
    # callframe array
    # TODO garbage collector

    def __init__(self):
        self.m_callframes = list() # list[CallFrame]
        starter_callframe = create_starter_callframe()
        starter_function  = starter_callframe.current_function()
        self.m_callframes.append(starter_callframe)
        self.m_callframe_index = 0

        self.m_stack = list() # list[Value]
        self.m_stack.append( starter_function )
    

    def current_callframe(self) -> CallFrame:
        return self.m_callframes[self.m_callframe_index]
    
    def stack_ptr(self) -> int:
        return len(self.m_stack)

    def stack_pop(self) -> Value:
        return self.m_stack.pop()
    
    def stack_push(self, value: Value) -> None:
        self.m_stack.append(value)
        return None
    
    def stack_value_at(self, abs_index: int) -> Value:
        return self.m_stack[abs_index]
    
    def stack_value_at_relative(self, rel_index: int) -> Value:
        abs_index = self.stack_ptr() + rel_index
        return self.m_stack[abs_index]
    
    def set_stack_value_at(self, abs_index: int, target_value: Value) -> None:
        self.m_stack[abs_index] = target_value
    


    def run(self):
        # next_callframe = CallFrame(fcn, 1)
        # self.m_callframes.append(next_callframe)
        current_callframe = self.current_callframe()

        is_done: bool = False
        while not is_done:
            op_code = current_callframe.opcode()
            match op_code:

                case (
                      OpCode.PLUS_F64 
                    | OpCode.MINUS_F64 
                    | OpCode.PROD_F64 
                    | OpCode.DIVIDE_F64 
                    | OpCode.POWER_F64
                    | OpCode.LESS_F64       
                    | OpCode.LESSTHEN_F64   
                    | OpCode.GREATER_F64    
                    | OpCode.GREATERTHEN_F64
                    | OpCode.EQUALEQUAL_F64 
                    | OpCode.NOTEQUAL_F64
                      ):
                    rhs: Value = self.stack_pop()
                    lhs: Value = self.stack_pop()
                    res_value: Value = float_binary_operator(lhs, rhs, op_code)
                    self.stack_push(res_value)
                    continue

                case (
                      OpCode.PLUS_I64 
                    | OpCode.MINUS_I64 
                    | OpCode.PROD_I64 
                    | OpCode.DIVIDE_I64 
                    | OpCode.POWER_I64
                    | OpCode.LESS_I64       
                    | OpCode.LESSTHEN_I64   
                    | OpCode.GREATER_I64    
                    | OpCode.GREATERTHEN_I64
                    | OpCode.EQUALEQUAL_I64 
                    | OpCode.NOTEQUAL_I64
                      ):
                    rhs: Value = self.stack_pop()
                    lhs: Value = self.stack_pop()
                    res_value: Value = int_binary_operator(lhs, rhs, op_code)
                    self.stack_push(res_value)
                    continue

                case OpCode.JUMP_FW:
                    n_bytes: int = current_callframe.opcode()
                    self.current_callframe().incr_instr_ptr(n_bytes)
                    continue

                case OpCode.JUMP_BW:
                    n_bytes: int = current_callframe.opcode()
                    self.current_callframe().decr_instr_ptr(n_bytes)
                    continue

                case OpCode.JUMP_FW_IF_FALSE:
                    
                    value: Value = self.stack_pop()
                    b: bool      = as_bool(value)
                    n_bytes: int = current_callframe.opcode()
                    if not b:
                        self.current_callframe().incr_instr_ptr(n_bytes)
                    continue

                case OpCode.CALL:
                    n_args: int            = current_callframe.opcode()
                    rel_index: int         = -(n_args + 1) # +1 due to that the function is also on the stack
                    sp: int                = self.stack_ptr()
                    sp_next_callframe: int = sp + rel_index
                    value: Value           = self.stack_value_at_relative(rel_index)
                    fcn: CompiledFunction  = as_function(value)
                    call_frame: CallFrame  = CallFrame(fcn, sp_next_callframe)
                    self.m_callframes.append(call_frame)
                    current_callframe       = call_frame
                    self.m_callframe_index += 1
                    continue

                case OpCode.RETURN:
                    # TODO: the stack is probably not correct at the last return
                    return_value: Value = self.stack_pop()
                    sp_return: int      = current_callframe.return_stack_address()
                    self.m_stack        = self.m_stack[0:sp_return]

                    self.m_callframes.pop() # drop the current callframe
                    self.m_callframe_index -= 1

                    if self.m_callframe_index < 0:
                        is_done = True
                        break

                    current_callframe = self.m_callframes[self.m_callframe_index]
                    self.stack_push(return_value)
                    continue

                case OpCode.GET_CONSTANT:
                    constant_index: int = current_callframe.opcode()
                    value: Value        = self.current_callframe().current_function().constant_at(constant_index)
                    self.stack_push(value)
                    continue

                case OpCode.GET_LOCAL:
                    local_index: int = current_callframe.opcode()
                    stack_index: int = self.current_callframe().local_index(local_index)
                    value: Value     = self.stack_value_at(stack_index)
                    self.stack_push(value)
                    continue

                case OpCode.SET_LOCAL:
                    target_value: Value = self.stack_pop()
                    local_index: int    = current_callframe.opcode()
                    stack_index: int    = self.current_callframe().local_index(local_index)
                    self.set_stack_value_at(stack_index, target_value)
                    continue

                case OpCode.PUSH_NIL:
                    value: Value = make_nil_value()
                    self.stack_push(value)
                    continue

                case OpCode.PUSH_TRUE:
                    value: Value = make_bool_value(True)
                    self.stack_push(value)
                    continue

                case OpCode.PUSH_FALSE:
                    value: Value = make_bool_value(False)
                    self.stack_push(value)
                    continue

                case OpCode.POP:
                    value: Value = self.stack_pop()
                    continue

                # case OpCode.POPN:
                    

                case OpCode.PRINT:
                    value: Value = self.stack_pop()
                    print_value(value)
                    continue

                case _:
                    raise Exception("implementation error")










